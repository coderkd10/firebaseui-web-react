(function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app-compat */ "./node_modules/@firebase/app-compat/dist/esm/index.esm2017.js");
/* harmony import */ var _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/auth/internal */ "./node_modules/@firebase/auth/dist/esm2017/internal.js");
/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/component */ "./node_modules/@firebase/component/dist/esm/index.esm2017.js");
/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/util */ "./node_modules/@firebase/util/dist/index.esm2017.js");





var name = "@firebase/auth-compat";
var version = "0.4.2";

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CORDOVA_ONDEVICEREADY_TIMEOUT_MS = 1000;
function _getCurrentScheme() {
    var _a;
    return ((_a = self === null || self === void 0 ? void 0 : self.location) === null || _a === void 0 ? void 0 : _a.protocol) || null;
}
/**
 * @return {boolean} Whether the current environment is http or https.
 */
function _isHttpOrHttps() {
    return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';
}
/**
 * @param {?string=} ua The user agent.
 * @return {boolean} Whether the app is rendered in a mobile iOS or Android
 *     Cordova environment.
 */
function _isAndroidOrIosCordovaScheme(ua = Object(_firebase_util__WEBPACK_IMPORTED_MODULE_3__["getUA"])()) {
    return !!((_getCurrentScheme() === 'file:' ||
        _getCurrentScheme() === 'ionic:' ||
        _getCurrentScheme() === 'capacitor:') &&
        ua.toLowerCase().match(/iphone|ipad|ipod|android/));
}
/**
 * @return {boolean} Whether the environment is a native environment, where
 *     CORS checks do not apply.
 */
function _isNativeEnvironment() {
    return Object(_firebase_util__WEBPACK_IMPORTED_MODULE_3__["isReactNative"])() || Object(_firebase_util__WEBPACK_IMPORTED_MODULE_3__["isNode"])();
}
/**
 * Checks whether the user agent is IE11.
 * @return {boolean} True if it is IE11.
 */
function _isIe11() {
    return Object(_firebase_util__WEBPACK_IMPORTED_MODULE_3__["isIE"])() && (document === null || document === void 0 ? void 0 : document.documentMode) === 11;
}
/**
 * Checks whether the user agent is Edge.
 * @param {string} userAgent The browser user agent string.
 * @return {boolean} True if it is Edge.
 */
function _isEdge(ua = Object(_firebase_util__WEBPACK_IMPORTED_MODULE_3__["getUA"])()) {
    return /Edge\/\d+/.test(ua);
}
/**
 * @param {?string=} opt_userAgent The navigator user agent.
 * @return {boolean} Whether local storage is not synchronized between an iframe
 *     and a popup of the same domain.
 */
function _isLocalStorageNotSynchronized(ua = Object(_firebase_util__WEBPACK_IMPORTED_MODULE_3__["getUA"])()) {
    return _isIe11() || _isEdge(ua);
}
/** @return {boolean} Whether web storage is supported. */
function _isWebStorageSupported() {
    try {
        const storage = self.localStorage;
        const key = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_generateEventId"]();
        if (storage) {
            // setItem will throw an exception if we cannot access WebStorage (e.g.,
            // Safari in private mode).
            storage['setItem'](key, '1');
            storage['removeItem'](key);
            // For browsers where iframe web storage does not synchronize with a popup
            // of the same domain, indexedDB is used for persistent storage. These
            // browsers include IE11 and Edge.
            // Make sure it is supported (IE11 and Edge private mode does not support
            // that).
            if (_isLocalStorageNotSynchronized()) {
                // In such browsers, if indexedDB is not supported, an iframe cannot be
                // notified of the popup sign in result.
                return Object(_firebase_util__WEBPACK_IMPORTED_MODULE_3__["isIndexedDBAvailable"])();
            }
            return true;
        }
    }
    catch (e) {
        // localStorage is not available from a worker. Test availability of
        // indexedDB.
        return _isWorker() && Object(_firebase_util__WEBPACK_IMPORTED_MODULE_3__["isIndexedDBAvailable"])();
    }
    return false;
}
/**
 * @param {?Object=} global The optional global scope.
 * @return {boolean} Whether current environment is a worker.
 */
function _isWorker() {
    // WorkerGlobalScope only defined in worker environment.
    return (typeof global !== 'undefined' &&
        'WorkerGlobalScope' in global &&
        'importScripts' in global);
}
function _isPopupRedirectSupported() {
    return ((_isHttpOrHttps() ||
        Object(_firebase_util__WEBPACK_IMPORTED_MODULE_3__["isBrowserExtension"])() ||
        _isAndroidOrIosCordovaScheme()) &&
        // React Native with remote debugging reports its location.protocol as
        // http.
        !_isNativeEnvironment() &&
        // Local storage has to be supported for browser popup and redirect
        // operations to work.
        _isWebStorageSupported() &&
        // DOM, popups and redirects are not supported within a worker.
        !_isWorker());
}
/** Quick check that indicates the platform *may* be Cordova */
function _isLikelyCordova() {
    return _isAndroidOrIosCordovaScheme() && typeof document !== 'undefined';
}
async function _isCordova() {
    if (!_isLikelyCordova()) {
        return false;
    }
    return new Promise(resolve => {
        const timeoutId = setTimeout(() => {
            // We've waited long enough; the telltale Cordova event didn't happen
            resolve(false);
        }, CORDOVA_ONDEVICEREADY_TIMEOUT_MS);
        document.addEventListener('deviceready', () => {
            clearTimeout(timeoutId);
            resolve(true);
        });
    });
}
function _getSelfWindow() {
    return typeof window !== 'undefined' ? window : null;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Persistence = {
    LOCAL: 'local',
    NONE: 'none',
    SESSION: 'session'
};
const _assert$3 = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_assert"];
const PERSISTENCE_KEY = 'persistence';
/**
 * Validates that an argument is a valid persistence value. If an invalid type
 * is specified, an error is thrown synchronously.
 */
function _validatePersistenceArgument(auth, persistence) {
    _assert$3(Object.values(Persistence).includes(persistence), auth, "invalid-persistence-type" /* exp.AuthErrorCode.INVALID_PERSISTENCE */);
    // Validate if the specified type is supported in the current environment.
    if (Object(_firebase_util__WEBPACK_IMPORTED_MODULE_3__["isReactNative"])()) {
        // This is only supported in a browser.
        _assert$3(persistence !== Persistence.SESSION, auth, "unsupported-persistence-type" /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */);
        return;
    }
    if (Object(_firebase_util__WEBPACK_IMPORTED_MODULE_3__["isNode"])()) {
        // Only none is supported in Node.js.
        _assert$3(persistence === Persistence.NONE, auth, "unsupported-persistence-type" /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */);
        return;
    }
    if (_isWorker()) {
        // In a worker environment, either LOCAL or NONE are supported.
        // If indexedDB not supported and LOCAL provided, throw an error
        _assert$3(persistence === Persistence.NONE ||
            (persistence === Persistence.LOCAL && Object(_firebase_util__WEBPACK_IMPORTED_MODULE_3__["isIndexedDBAvailable"])()), auth, "unsupported-persistence-type" /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */);
        return;
    }
    // This is restricted by what the browser supports.
    _assert$3(persistence === Persistence.NONE || _isWebStorageSupported(), auth, "unsupported-persistence-type" /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */);
}
async function _savePersistenceForRedirect(auth) {
    await auth._initializationPromise;
    const session = getSessionStorageIfAvailable();
    const key = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_persistenceKeyName"](PERSISTENCE_KEY, auth.config.apiKey, auth.name);
    if (session) {
        session.setItem(key, auth._getPersistence());
    }
}
function _getPersistencesFromRedirect(apiKey, appName) {
    const session = getSessionStorageIfAvailable();
    if (!session) {
        return [];
    }
    const key = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_persistenceKeyName"](PERSISTENCE_KEY, apiKey, appName);
    const persistence = session.getItem(key);
    switch (persistence) {
        case Persistence.NONE:
            return [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["inMemoryPersistence"]];
        case Persistence.LOCAL:
            return [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["indexedDBLocalPersistence"], _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["browserSessionPersistence"]];
        case Persistence.SESSION:
            return [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["browserSessionPersistence"]];
        default:
            return [];
    }
}
/** Returns session storage, or null if the property access errors */
function getSessionStorageIfAvailable() {
    var _a;
    try {
        return ((_a = _getSelfWindow()) === null || _a === void 0 ? void 0 : _a.sessionStorage) || null;
    }
    catch (e) {
        return null;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _assert$2 = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_assert"];
/** Platform-agnostic popup-redirect resolver */
class CompatPopupRedirectResolver {
    constructor() {
        // Create both resolvers for dynamic resolution later
        this.browserResolver = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_getInstance"](_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["browserPopupRedirectResolver"]);
        this.cordovaResolver = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_getInstance"](_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["cordovaPopupRedirectResolver"]);
        // The actual resolver in use: either browserResolver or cordovaResolver.
        this.underlyingResolver = null;
        this._redirectPersistence = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["browserSessionPersistence"];
        this._completeRedirectFn = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_getRedirectResult"];
        this._overrideRedirectResult = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_overrideRedirectResult"];
    }
    async _initialize(auth) {
        await this.selectUnderlyingResolver();
        return this.assertedUnderlyingResolver._initialize(auth);
    }
    async _openPopup(auth, provider, authType, eventId) {
        await this.selectUnderlyingResolver();
        return this.assertedUnderlyingResolver._openPopup(auth, provider, authType, eventId);
    }
    async _openRedirect(auth, provider, authType, eventId) {
        await this.selectUnderlyingResolver();
        return this.assertedUnderlyingResolver._openRedirect(auth, provider, authType, eventId);
    }
    _isIframeWebStorageSupported(auth, cb) {
        this.assertedUnderlyingResolver._isIframeWebStorageSupported(auth, cb);
    }
    _originValidation(auth) {
        return this.assertedUnderlyingResolver._originValidation(auth);
    }
    get _shouldInitProactively() {
        return _isLikelyCordova() || this.browserResolver._shouldInitProactively;
    }
    get assertedUnderlyingResolver() {
        _assert$2(this.underlyingResolver, "internal-error" /* exp.AuthErrorCode.INTERNAL_ERROR */);
        return this.underlyingResolver;
    }
    async selectUnderlyingResolver() {
        if (this.underlyingResolver) {
            return;
        }
        // We haven't yet determined whether or not we're in Cordova; go ahead
        // and determine that state now.
        const isCordova = await _isCordova();
        this.underlyingResolver = isCordova
            ? this.cordovaResolver
            : this.browserResolver;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function unwrap(object) {
    return object.unwrap();
}
function wrapped(object) {
    return object.wrapped();
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function credentialFromResponse(userCredential) {
    return credentialFromObject(userCredential);
}
function attachExtraErrorFields(auth, e) {
    var _a;
    // The response contains all fields from the server which may or may not
    // actually match the underlying type
    const response = (_a = e.customData) === null || _a === void 0 ? void 0 : _a._tokenResponse;
    if ((e === null || e === void 0 ? void 0 : e.code) === 'auth/multi-factor-auth-required') {
        const mfaErr = e;
        mfaErr.resolver = new MultiFactorResolver(auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["getMultiFactorResolver"](auth, e));
    }
    else if (response) {
        const credential = credentialFromObject(e);
        const credErr = e;
        if (credential) {
            credErr.credential = credential;
            credErr.tenantId = response.tenantId || undefined;
            credErr.email = response.email || undefined;
            credErr.phoneNumber = response.phoneNumber || undefined;
        }
    }
}
function credentialFromObject(object) {
    const { _tokenResponse } = (object instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_3__["FirebaseError"] ? object.customData : object);
    if (!_tokenResponse) {
        return null;
    }
    // Handle phone Auth credential responses, as they have a different format
    // from other backend responses (i.e. no providerId). This is also only the
    // case for user credentials (does not work for errors).
    if (!(object instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_3__["FirebaseError"])) {
        if ('temporaryProof' in _tokenResponse && 'phoneNumber' in _tokenResponse) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["PhoneAuthProvider"].credentialFromResult(object);
        }
    }
    const providerId = _tokenResponse.providerId;
    // Email and password is not supported as there is no situation where the
    // server would return the password to the client.
    if (!providerId || providerId === _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["ProviderId"].PASSWORD) {
        return null;
    }
    let provider;
    switch (providerId) {
        case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["ProviderId"].GOOGLE:
            provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["GoogleAuthProvider"];
            break;
        case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["ProviderId"].FACEBOOK:
            provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["FacebookAuthProvider"];
            break;
        case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["ProviderId"].GITHUB:
            provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["GithubAuthProvider"];
            break;
        case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["ProviderId"].TWITTER:
            provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["TwitterAuthProvider"];
            break;
        default:
            const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce } = _tokenResponse;
            if (!oauthAccessToken &&
                !oauthTokenSecret &&
                !oauthIdToken &&
                !pendingToken) {
                return null;
            }
            // TODO(avolkovi): uncomment this and get it working with SAML & OIDC
            if (pendingToken) {
                if (providerId.startsWith('saml.')) {
                    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["SAMLAuthCredential"]._create(providerId, pendingToken);
                }
                else {
                    // OIDC and non-default providers excluding Twitter.
                    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["OAuthCredential"]._fromParams({
                        providerId,
                        signInMethod: providerId,
                        pendingToken,
                        idToken: oauthIdToken,
                        accessToken: oauthAccessToken
                    });
                }
            }
            return new _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["OAuthProvider"](providerId).credential({
                idToken: oauthIdToken,
                accessToken: oauthAccessToken,
                rawNonce: nonce
            });
    }
    return object instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_3__["FirebaseError"]
        ? provider.credentialFromError(object)
        : provider.credentialFromResult(object);
}
function convertCredential(auth, credentialPromise) {
    return credentialPromise
        .catch(e => {
        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_3__["FirebaseError"]) {
            attachExtraErrorFields(auth, e);
        }
        throw e;
    })
        .then(credential => {
        const operationType = credential.operationType;
        const user = credential.user;
        return {
            operationType,
            credential: credentialFromResponse(credential),
            additionalUserInfo: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["getAdditionalUserInfo"](credential),
            user: User.getOrCreate(user)
        };
    });
}
async function convertConfirmationResult(auth, confirmationResultPromise) {
    const confirmationResultExp = await confirmationResultPromise;
    return {
        verificationId: confirmationResultExp.verificationId,
        confirm: (verificationCode) => convertCredential(auth, confirmationResultExp.confirm(verificationCode))
    };
}
class MultiFactorResolver {
    constructor(auth, resolver) {
        this.resolver = resolver;
        this.auth = wrapped(auth);
    }
    get session() {
        return this.resolver.session;
    }
    get hints() {
        return this.resolver.hints;
    }
    resolveSignIn(assertion) {
        return convertCredential(unwrap(this.auth), this.resolver.resolveSignIn(assertion));
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class User {
    constructor(_delegate) {
        this._delegate = _delegate;
        this.multiFactor = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["multiFactor"](_delegate);
    }
    static getOrCreate(user) {
        if (!User.USER_MAP.has(user)) {
            User.USER_MAP.set(user, new User(user));
        }
        return User.USER_MAP.get(user);
    }
    delete() {
        return this._delegate.delete();
    }
    reload() {
        return this._delegate.reload();
    }
    toJSON() {
        return this._delegate.toJSON();
    }
    getIdTokenResult(forceRefresh) {
        return this._delegate.getIdTokenResult(forceRefresh);
    }
    getIdToken(forceRefresh) {
        return this._delegate.getIdToken(forceRefresh);
    }
    linkAndRetrieveDataWithCredential(credential) {
        return this.linkWithCredential(credential);
    }
    async linkWithCredential(credential) {
        return convertCredential(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["linkWithCredential"](this._delegate, credential));
    }
    async linkWithPhoneNumber(phoneNumber, applicationVerifier) {
        return convertConfirmationResult(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["linkWithPhoneNumber"](this._delegate, phoneNumber, applicationVerifier));
    }
    async linkWithPopup(provider) {
        return convertCredential(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["linkWithPopup"](this._delegate, provider, CompatPopupRedirectResolver));
    }
    async linkWithRedirect(provider) {
        await _savePersistenceForRedirect(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_castAuth"](this.auth));
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["linkWithRedirect"](this._delegate, provider, CompatPopupRedirectResolver);
    }
    reauthenticateAndRetrieveDataWithCredential(credential) {
        return this.reauthenticateWithCredential(credential);
    }
    async reauthenticateWithCredential(credential) {
        return convertCredential(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["reauthenticateWithCredential"](this._delegate, credential));
    }
    reauthenticateWithPhoneNumber(phoneNumber, applicationVerifier) {
        return convertConfirmationResult(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["reauthenticateWithPhoneNumber"](this._delegate, phoneNumber, applicationVerifier));
    }
    reauthenticateWithPopup(provider) {
        return convertCredential(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["reauthenticateWithPopup"](this._delegate, provider, CompatPopupRedirectResolver));
    }
    async reauthenticateWithRedirect(provider) {
        await _savePersistenceForRedirect(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_castAuth"](this.auth));
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["reauthenticateWithRedirect"](this._delegate, provider, CompatPopupRedirectResolver);
    }
    sendEmailVerification(actionCodeSettings) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["sendEmailVerification"](this._delegate, actionCodeSettings);
    }
    async unlink(providerId) {
        await _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["unlink"](this._delegate, providerId);
        return this;
    }
    updateEmail(newEmail) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["updateEmail"](this._delegate, newEmail);
    }
    updatePassword(newPassword) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["updatePassword"](this._delegate, newPassword);
    }
    updatePhoneNumber(phoneCredential) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["updatePhoneNumber"](this._delegate, phoneCredential);
    }
    updateProfile(profile) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["updateProfile"](this._delegate, profile);
    }
    verifyBeforeUpdateEmail(newEmail, actionCodeSettings) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["verifyBeforeUpdateEmail"](this._delegate, newEmail, actionCodeSettings);
    }
    get emailVerified() {
        return this._delegate.emailVerified;
    }
    get isAnonymous() {
        return this._delegate.isAnonymous;
    }
    get metadata() {
        return this._delegate.metadata;
    }
    get phoneNumber() {
        return this._delegate.phoneNumber;
    }
    get providerData() {
        return this._delegate.providerData;
    }
    get refreshToken() {
        return this._delegate.refreshToken;
    }
    get tenantId() {
        return this._delegate.tenantId;
    }
    get displayName() {
        return this._delegate.displayName;
    }
    get email() {
        return this._delegate.email;
    }
    get photoURL() {
        return this._delegate.photoURL;
    }
    get providerId() {
        return this._delegate.providerId;
    }
    get uid() {
        return this._delegate.uid;
    }
    get auth() {
        return this._delegate.auth;
    }
}
// Maintain a map so that there's always a 1:1 mapping between new User and
// legacy compat users
User.USER_MAP = new WeakMap();

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _assert$1 = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_assert"];
class Auth {
    constructor(app, provider) {
        this.app = app;
        if (provider.isInitialized()) {
            this._delegate = provider.getImmediate();
            this.linkUnderlyingAuth();
            return;
        }
        const { apiKey } = app.options;
        // TODO: platform needs to be determined using heuristics
        _assert$1(apiKey, "invalid-api-key" /* exp.AuthErrorCode.INVALID_API_KEY */, {
            appName: app.name
        });
        // TODO: platform needs to be determined using heuristics
        _assert$1(apiKey, "invalid-api-key" /* exp.AuthErrorCode.INVALID_API_KEY */, {
            appName: app.name
        });
        // Only use a popup/redirect resolver in browser environments
        const resolver = typeof window !== 'undefined' ? CompatPopupRedirectResolver : undefined;
        this._delegate = provider.initialize({
            options: {
                persistence: buildPersistenceHierarchy(apiKey, app.name),
                popupRedirectResolver: resolver
            }
        });
        this._delegate._updateErrorMap(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["debugErrorMap"]);
        this.linkUnderlyingAuth();
    }
    get emulatorConfig() {
        return this._delegate.emulatorConfig;
    }
    get currentUser() {
        if (!this._delegate.currentUser) {
            return null;
        }
        return User.getOrCreate(this._delegate.currentUser);
    }
    get languageCode() {
        return this._delegate.languageCode;
    }
    set languageCode(languageCode) {
        this._delegate.languageCode = languageCode;
    }
    get settings() {
        return this._delegate.settings;
    }
    get tenantId() {
        return this._delegate.tenantId;
    }
    set tenantId(tid) {
        this._delegate.tenantId = tid;
    }
    useDeviceLanguage() {
        this._delegate.useDeviceLanguage();
    }
    signOut() {
        return this._delegate.signOut();
    }
    useEmulator(url, options) {
        _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["connectAuthEmulator"](this._delegate, url, options);
    }
    applyActionCode(code) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["applyActionCode"](this._delegate, code);
    }
    checkActionCode(code) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["checkActionCode"](this._delegate, code);
    }
    confirmPasswordReset(code, newPassword) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["confirmPasswordReset"](this._delegate, code, newPassword);
    }
    async createUserWithEmailAndPassword(email, password) {
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["createUserWithEmailAndPassword"](this._delegate, email, password));
    }
    fetchProvidersForEmail(email) {
        return this.fetchSignInMethodsForEmail(email);
    }
    fetchSignInMethodsForEmail(email) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["fetchSignInMethodsForEmail"](this._delegate, email);
    }
    isSignInWithEmailLink(emailLink) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["isSignInWithEmailLink"](this._delegate, emailLink);
    }
    async getRedirectResult() {
        _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment" /* exp.AuthErrorCode.OPERATION_NOT_SUPPORTED */);
        const credential = await _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["getRedirectResult"](this._delegate, CompatPopupRedirectResolver);
        if (!credential) {
            return {
                credential: null,
                user: null
            };
        }
        return convertCredential(this._delegate, Promise.resolve(credential));
    }
    // This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.
    // It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it
    // out of autogenerated documentation pages to reduce accidental misuse.
    addFrameworkForLogging(framework) {
        _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["addFrameworkForLogging"](this._delegate, framework);
    }
    onAuthStateChanged(nextOrObserver, errorFn, completed) {
        const { next, error, complete } = wrapObservers(nextOrObserver, errorFn, completed);
        return this._delegate.onAuthStateChanged(next, error, complete);
    }
    onIdTokenChanged(nextOrObserver, errorFn, completed) {
        const { next, error, complete } = wrapObservers(nextOrObserver, errorFn, completed);
        return this._delegate.onIdTokenChanged(next, error, complete);
    }
    sendSignInLinkToEmail(email, actionCodeSettings) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["sendSignInLinkToEmail"](this._delegate, email, actionCodeSettings);
    }
    sendPasswordResetEmail(email, actionCodeSettings) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["sendPasswordResetEmail"](this._delegate, email, actionCodeSettings || undefined);
    }
    async setPersistence(persistence) {
        _validatePersistenceArgument(this._delegate, persistence);
        let converted;
        switch (persistence) {
            case Persistence.SESSION:
                converted = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["browserSessionPersistence"];
                break;
            case Persistence.LOCAL:
                // Not using isIndexedDBAvailable() since it only checks if indexedDB is defined.
                const isIndexedDBFullySupported = await _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_getInstance"](_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["indexedDBLocalPersistence"])
                    ._isAvailable();
                converted = isIndexedDBFullySupported
                    ? _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["indexedDBLocalPersistence"]
                    : _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["browserLocalPersistence"];
                break;
            case Persistence.NONE:
                converted = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["inMemoryPersistence"];
                break;
            default:
                return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_fail"]("argument-error" /* exp.AuthErrorCode.ARGUMENT_ERROR */, {
                    appName: this._delegate.name
                });
        }
        return this._delegate.setPersistence(converted);
    }
    signInAndRetrieveDataWithCredential(credential) {
        return this.signInWithCredential(credential);
    }
    signInAnonymously() {
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["signInAnonymously"](this._delegate));
    }
    signInWithCredential(credential) {
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["signInWithCredential"](this._delegate, credential));
    }
    signInWithCustomToken(token) {
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["signInWithCustomToken"](this._delegate, token));
    }
    signInWithEmailAndPassword(email, password) {
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["signInWithEmailAndPassword"](this._delegate, email, password));
    }
    signInWithEmailLink(email, emailLink) {
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["signInWithEmailLink"](this._delegate, email, emailLink));
    }
    signInWithPhoneNumber(phoneNumber, applicationVerifier) {
        return convertConfirmationResult(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["signInWithPhoneNumber"](this._delegate, phoneNumber, applicationVerifier));
    }
    async signInWithPopup(provider) {
        _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment" /* exp.AuthErrorCode.OPERATION_NOT_SUPPORTED */);
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["signInWithPopup"](this._delegate, provider, CompatPopupRedirectResolver));
    }
    async signInWithRedirect(provider) {
        _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment" /* exp.AuthErrorCode.OPERATION_NOT_SUPPORTED */);
        await _savePersistenceForRedirect(this._delegate);
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["signInWithRedirect"](this._delegate, provider, CompatPopupRedirectResolver);
    }
    updateCurrentUser(user) {
        // remove ts-ignore once overloads are defined for exp functions to accept compat objects
        // @ts-ignore
        return this._delegate.updateCurrentUser(user);
    }
    verifyPasswordResetCode(code) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["verifyPasswordResetCode"](this._delegate, code);
    }
    unwrap() {
        return this._delegate;
    }
    _delete() {
        return this._delegate._delete();
    }
    linkUnderlyingAuth() {
        this._delegate.wrapped = () => this;
    }
}
Auth.Persistence = Persistence;
function wrapObservers(nextOrObserver, error, complete) {
    let next = nextOrObserver;
    if (typeof nextOrObserver !== 'function') {
        ({ next, error, complete } = nextOrObserver);
    }
    // We know 'next' is now a function
    const oldNext = next;
    const newNext = (user) => oldNext(user && User.getOrCreate(user));
    return {
        next: newNext,
        error: error,
        complete
    };
}
function buildPersistenceHierarchy(apiKey, appName) {
    // Note this is slightly different behavior: in this case, the stored
    // persistence is checked *first* rather than last. This is because we want
    // to prefer stored persistence type in the hierarchy. This is an empty
    // array if window is not available or there is no pending redirect
    const persistences = _getPersistencesFromRedirect(apiKey, appName);
    // If "self" is available, add indexedDB
    if (typeof self !== 'undefined' &&
        !persistences.includes(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["indexedDBLocalPersistence"])) {
        persistences.push(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["indexedDBLocalPersistence"]);
    }
    // If "window" is available, add HTML Storage persistences
    if (typeof window !== 'undefined') {
        for (const persistence of [
            _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["browserLocalPersistence"],
            _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["browserSessionPersistence"]
        ]) {
            if (!persistences.includes(persistence)) {
                persistences.push(persistence);
            }
        }
    }
    // Add in-memory as a final fallback
    if (!persistences.includes(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["inMemoryPersistence"])) {
        persistences.push(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["inMemoryPersistence"]);
    }
    return persistences;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PhoneAuthProvider {
    constructor() {
        this.providerId = 'phone';
        // TODO: remove ts-ignore when moving types from auth-types to auth-compat
        // @ts-ignore
        this._delegate = new _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["PhoneAuthProvider"](unwrap(_firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__["default"].auth()));
    }
    static credential(verificationId, verificationCode) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["PhoneAuthProvider"].credential(verificationId, verificationCode);
    }
    verifyPhoneNumber(phoneInfoOptions, applicationVerifier) {
        return this._delegate.verifyPhoneNumber(
        // The implementation matches but the types are subtly incompatible
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        phoneInfoOptions, applicationVerifier);
    }
    unwrap() {
        return this._delegate;
    }
}
PhoneAuthProvider.PHONE_SIGN_IN_METHOD = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["PhoneAuthProvider"].PHONE_SIGN_IN_METHOD;
PhoneAuthProvider.PROVIDER_ID = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["PhoneAuthProvider"].PROVIDER_ID;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _assert = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["_assert"];
class RecaptchaVerifier {
    constructor(container, parameters, app = _firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__["default"].app()) {
        var _a;
        // API key is required for web client RPC calls.
        _assert((_a = app.options) === null || _a === void 0 ? void 0 : _a.apiKey, "invalid-api-key" /* exp.AuthErrorCode.INVALID_API_KEY */, {
            appName: app.name
        });
        this._delegate = new _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["RecaptchaVerifier"](container, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parameters, 
        // TODO: remove ts-ignore when moving types from auth-types to auth-compat
        // @ts-ignore
        app.auth());
        this.type = this._delegate.type;
    }
    clear() {
        this._delegate.clear();
    }
    render() {
        return this._delegate.render();
    }
    verify() {
        return this._delegate.verify();
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const AUTH_TYPE = 'auth-compat';
// Create auth components to register with firebase.
// Provides Auth public APIs.
function registerAuthCompat(instance) {
    instance.INTERNAL.registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__["Component"](AUTH_TYPE, container => {
        // getImmediate for FirebaseApp will always succeed
        const app = container.getProvider('app-compat').getImmediate();
        const authProvider = container.getProvider('auth');
        return new Auth(app, authProvider);
    }, "PUBLIC" /* ComponentType.PUBLIC */)
        .setServiceProps({
        ActionCodeInfo: {
            Operation: {
                EMAIL_SIGNIN: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["ActionCodeOperation"].EMAIL_SIGNIN,
                PASSWORD_RESET: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["ActionCodeOperation"].PASSWORD_RESET,
                RECOVER_EMAIL: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["ActionCodeOperation"].RECOVER_EMAIL,
                REVERT_SECOND_FACTOR_ADDITION: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["ActionCodeOperation"].REVERT_SECOND_FACTOR_ADDITION,
                VERIFY_AND_CHANGE_EMAIL: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["ActionCodeOperation"].VERIFY_AND_CHANGE_EMAIL,
                VERIFY_EMAIL: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["ActionCodeOperation"].VERIFY_EMAIL
            }
        },
        EmailAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["EmailAuthProvider"],
        FacebookAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["FacebookAuthProvider"],
        GithubAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["GithubAuthProvider"],
        GoogleAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["GoogleAuthProvider"],
        OAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["OAuthProvider"],
        SAMLAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["SAMLAuthProvider"],
        PhoneAuthProvider: PhoneAuthProvider,
        PhoneMultiFactorGenerator: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["PhoneMultiFactorGenerator"],
        RecaptchaVerifier: RecaptchaVerifier,
        TwitterAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["TwitterAuthProvider"],
        Auth,
        AuthCredential: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__["AuthCredential"],
        Error: _firebase_util__WEBPACK_IMPORTED_MODULE_3__["FirebaseError"]
    })
        .setInstantiationMode("LAZY" /* InstantiationMode.LAZY */)
        .setMultipleInstances(false));
    instance.registerVersion(name, version);
}
registerAuthCompat(_firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__["default"]);
//# sourceMappingURL=index.esm2017.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ })